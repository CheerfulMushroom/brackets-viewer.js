!function(e){var t={};function n(o){if(t[o])return t[o].exports;var s=t[o]={i:o,l:!1,exports:{}};return e[o].call(s.exports,s,s.exports,n),s.l=!0,s.exports}n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(o,s,function(t){return e[t]}.bind(null,s));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),n(1);const o=n(2);window.bracketsViewer=new class{constructor(){this.teamRefsDOM={}}render(e){const t=$("#root");if(0===t.length)throw Error('Root not found. You must have a root element with id "root"');switch(e.stage.type){case"round_robin":this.renderRoundRobin(t,e);break;case"single_elimination":case"double_elimination":this.renderElimination(t,e);break;default:throw Error("Unknown bracket type: "+e.stage.type)}}renderRoundRobin(e,t){t.participants.map(e=>this.teamRefsDOM[e.id]=[]),this.participants=t.participants;const n=$('<div class="round-robin">');let s=1;for(const e of o.splitBy(t.matches,"group_id")){const t=$('<section class="group">').append($("<h2>").text("Group "+s++));let r=1;for(const n of o.splitBy(e,"round_id")){const e=$('<article class="round">').append($("<h3>").text("Round "+r));for(const t of n)e.append(this.renderMatch(t));t.append(e),r++}t.append(this.renderTable(e)),n.append(t)}e.append($("<h1>").text(t.stage.name)),e.append(n)}renderTable(e){const t=o.getRanking(e),n=$("<table>"),s=$("<tr>");for(const e in t[0]){const t=o.rankingHeader(e);s.append($("<th>").text(t.value).attr("title",t.tooltip))}n.append(s);for(const e of t){const t=$("<tr>");for(const n in e){let o=e[n];if("id"===n){const e=this.participants.find(e=>e.id===o);if(void 0!==e){const n=$("<td>").text(e.name),o=e.id;this.teamRefsDOM[o].push(n.get(0)),n.hover(()=>$(this.teamRefsDOM[o]).addClass("hover"),()=>$(this.teamRefsDOM[o]).removeClass("hover")),t.append(n);continue}}t.append($("<td>").text(o))}n.append(t)}return n}renderElimination(e,t){t.participants.map(e=>this.teamRefsDOM[e.id]=[]);const n=o.splitBy(t.matches,"group_id");if(this.participants=t.participants,e.append($("<h1>").text(t.stage.name)),"single_elimination"===t.stage.type){const t=!!n[1];this.renderBracket(e,o.splitBy(n[0],"round_id"),e=>"Round "+e),t&&this.renderFinal("consolation_final",n[1])}else if("double_elimination"===t.stage.type){const t=!!n[2];this.renderBracket(e,o.splitBy(n[0],"round_id"),e=>"WB Round "+e,!1,t),this.renderBracket(e,o.splitBy(n[1],"round_id"),e=>"LB Round "+e,!0),t&&this.renderFinal("grand_final",n[2])}}renderBracket(e,t,n,o,s){const r=$('<section class="bracket">');let i=1;for(const e of t){const a=$('<article class="round">').append($("<h3>").text(n(i)));for(const n of e){let e;e=o?{connectPrevious:i>1&&(i%2==1?"square":"straight"),connectNext:i<t.length&&(i%2==0?"square":"straight")}:{connectPrevious:i>1&&"square",connectNext:i<t.length?"square":!!s&&"straight"},a.append(this.renderMatch(n,e))}r.append(a),i++}e.append(r)}renderFinal(e,t){const n=$(".bracket").eq(0),o=1===t.length?()=>"Grand Final":e=>"Grand Final R"+(e+1);for(let s=0;s<t.length;s++){const r=this.renderMatch(t[s],{connectPrevious:"grand_final"===e&&0===s&&"straight",connectNext:2===t.length&&0===s&&"straight"}),i=$('<article class="round">').append($("<h3>").text("grand_final"===e?o(s):"Consolation Final"));i.append(r),n.append(i)}}renderMatch(e,t){const n=this.renderTeam(e.opponent1),o=this.renderTeam(e.opponent2),s=$('<div class="teams">').append(n).append(o),r=$('<div class="match">').append(s);return t?(t.connectPrevious&&s.addClass("connect-previous"),t.connectNext&&r.addClass("connect-next"),"straight"===t.connectPrevious&&s.addClass("straight"),"straight"===t.connectNext&&r.addClass("straight"),r):r}renderTeam(e){const t=$('<div class="team">'),n=$('<div class="name">'),o=$('<div class="score">');if(null===e)n.text("BYE");else{const t=this.participants.find(t=>t.id===e.id);n.text(void 0===t?"TBD":t.name),o.text(void 0===e.score?"-":e.score),e.result&&"win"===e.result&&(n.addClass("win"),o.addClass("win")),e.result&&"loss"===e.result&&(n.addClass("loss"),o.addClass("loss"))}if(t.append(n).append(o),e&&null!==e.id){const n=e.id;this.teamRefsDOM[n].push(t.get(0)),t.hover(()=>$(this.teamRefsDOM[n]).addClass("hover"),()=>$(this.teamRefsDOM[n]).removeClass("hover"))}return t}}},function(e,t,n){},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getRanking=t.rankingHeader=t.splitBy=void 0,t.splitBy=function(e,t){const n=Object();for(const o of e)n[o[t]]||(n[o[t]]=[]),n[o[t]].push(o);return Object.values(n)};const o={rank:{value:"#",tooltip:"Rank"},id:{value:"Name",tooltip:"Name"},played:{value:"P",tooltip:"Played"},wins:{value:"W",tooltip:"Wins"},draws:{value:"D",tooltip:"Draws"},losses:{value:"L",tooltip:"Losses"},forfeits:{value:"F",tooltip:"Forfeits"},scoreFor:{value:"SF",tooltip:"Score For"},scoreAgainst:{value:"SA",tooltip:"Score Against"},scoreDifference:{value:"+/-",tooltip:"Score Difference"},points:{value:"Pts",tooltip:"Points"}};t.rankingHeader=function(e){return o[e]},t.getRanking=function(e,t){const n={};function o(e,o){if(!e||null===e.id)return;const s=n[e.id]||{rank:0,id:0,played:0,wins:0,draws:0,losses:0,forfeits:0,scoreFor:0,scoreAgainst:0,scoreDifference:0,points:0};s.id=e.id,s.played++,"win"===e.result&&s.wins++,"draw"===e.result&&s.draws++,"loss"===e.result&&s.losses++,e.forfeit&&s.forfeits++,s.scoreFor+=e.score||0,s.scoreAgainst+=o&&o.score||0,s.scoreDifference=s.scoreFor-s.scoreAgainst;const r=t||(e=>3*e.wins+1*e.draws+0*e.losses);s.points=r(s),n[e.id]=s}for(const t of e)o(t.opponent1,t.opponent2),o(t.opponent2,t.opponent1);const s=Object.values(n).sort((e,t)=>t.points-e.points);let r={value:0,lastPoints:-1};for(const e of s)e.rank=r.lastPoints!==e.points?++r.value:r.value,r.lastPoints=e.points;return s}}]);