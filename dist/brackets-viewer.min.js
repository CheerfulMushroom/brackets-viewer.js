!function(e){var t={};function n(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(s,o,function(t){return e[t]}.bind(null,o));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),n(1);const s=n(2);window.bracketsViewer=new class{constructor(){this.teamRefsDOM={}}render(e,t){const n=$(e);if(0===n.length)throw Error('Root not found. You must have a root element with id "root"');switch(t.stage.type){case"round_robin":this.renderRoundRobin(n,t);break;case"single_elimination":case"double_elimination":this.renderElimination(n,t);break;default:throw Error("Unknown bracket type: "+t.stage.type)}}renderRoundRobin(e,t){t.participants.map(e=>this.teamRefsDOM[e.id]=[]),this.participants=t.participants;const n=$('<div class="round-robin">');let o=1;for(const e of s.splitBy(t.matches,"group_id")){const t=$('<section class="group">').append($("<h2>").text("Group "+o++));let r=1;for(const n of s.splitBy(e,"round_id")){const e=$('<article class="round">').append($("<h3>").text("Round "+r));for(const t of n)e.append(this.renderMatch(t));t.append(e),r++}t.append(this.renderTable(e)),n.append(t)}e.append($("<h1>").text(t.stage.name)),e.append(n)}renderTable(e){const t=s.getRanking(e),n=$("<table>"),o=$("<tr>");for(const e in t[0]){const t=s.rankingHeader(e);o.append($("<th>").text(t.value).attr("title",t.tooltip))}n.append(o);for(const e of t){const t=$("<tr>");for(const n in e){let s=e[n];if("id"===n){const e=this.participants.find(e=>e.id===s);if(void 0!==e){const n=$("<td>").text(e.name),s=e.id;this.teamRefsDOM[s].push(n.get(0)),n.hover(()=>$(this.teamRefsDOM[s]).addClass("hover"),()=>$(this.teamRefsDOM[s]).removeClass("hover")),t.append(n);continue}}t.append($("<td>").text(s))}n.append(t)}return n}renderElimination(e,t){t.participants.map(e=>this.teamRefsDOM[e.id]=[]);const n=s.splitBy(t.matches,"group_id");if(this.participants=t.participants,e.append($("<h1>").text(t.stage.name)),"single_elimination"===t.stage.type){const t=!!n[1];this.renderBracket(e,s.splitBy(n[0],"round_id"),e=>"Round "+e),t&&this.renderFinal("consolation_final",n[1])}else if("double_elimination"===t.stage.type){const t=!!n[2];this.renderBracket(e,s.splitBy(n[0],"round_id"),e=>"WB Round "+e,!1,t),this.renderBracket(e,s.splitBy(n[1],"round_id"),e=>"LB Round "+e,!0),t&&this.renderFinal("grand_final",n[2])}}renderBracket(e,t,n,s,o){const r=$('<section class="bracket">');let i=1;for(const e of t){const a=$('<article class="round">').append($("<h3>").text(n(i)));for(const n of e){let e;e=s?{connectPrevious:i>1&&(i%2==1?"square":"straight"),connectNext:i<t.length&&(i%2==0?"square":"straight")}:{connectPrevious:i>1&&"square",connectNext:i<t.length?"square":!!o&&"straight"},a.append(this.renderMatch(n,e))}r.append(a),i++}e.append(r)}renderFinal(e,t){const n=$(".bracket").eq(0),s=1===t.length?()=>"Grand Final":e=>"Grand Final R"+(e+1);for(let o=0;o<t.length;o++){const r=this.renderMatch(t[o],{connectPrevious:"grand_final"===e&&0===o&&"straight",connectNext:2===t.length&&0===o&&"straight"}),i=$('<article class="round">').append($("<h3>").text("grand_final"===e?s(o):"Consolation Final"));i.append(r),n.append(i)}}renderMatch(e,t){const n=this.renderTeam(e.opponent1),s=this.renderTeam(e.opponent2),o=$('<div class="teams">').append(n).append(s),r=$('<div class="match">').append(o);return t?(t.connectPrevious&&o.addClass("connect-previous"),t.connectNext&&r.addClass("connect-next"),"straight"===t.connectPrevious&&o.addClass("straight"),"straight"===t.connectNext&&r.addClass("straight"),r):r}renderTeam(e){const t=$('<div class="team">'),n=$('<div class="name">'),s=$('<div class="score">');if(null===e)n.text("BYE");else{const t=this.participants.find(t=>t.id===e.id);n.text(void 0===t?"TBD":t.name),s.text(void 0===e.score?"-":e.score),e.result&&"win"===e.result&&(n.addClass("win"),s.addClass("win")),e.result&&"loss"===e.result&&(n.addClass("loss"),s.addClass("loss"))}if(t.append(n).append(s),e&&null!==e.id){const n=e.id;this.teamRefsDOM[n].push(t.get(0)),t.hover(()=>$(this.teamRefsDOM[n]).addClass("hover"),()=>$(this.teamRefsDOM[n]).removeClass("hover"))}return t}}},function(e,t,n){},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getRanking=t.rankingHeader=t.splitBy=void 0,t.splitBy=function(e,t){const n=Object();for(const s of e)n[s[t]]||(n[s[t]]=[]),n[s[t]].push(s);return Object.values(n)};const s={rank:{value:"#",tooltip:"Rank"},id:{value:"Name",tooltip:"Name"},played:{value:"P",tooltip:"Played"},wins:{value:"W",tooltip:"Wins"},draws:{value:"D",tooltip:"Draws"},losses:{value:"L",tooltip:"Losses"},forfeits:{value:"F",tooltip:"Forfeits"},scoreFor:{value:"SF",tooltip:"Score For"},scoreAgainst:{value:"SA",tooltip:"Score Against"},scoreDifference:{value:"+/-",tooltip:"Score Difference"},points:{value:"Pts",tooltip:"Points"}};t.rankingHeader=function(e){return s[e]},t.getRanking=function(e,t){const n={};function s(e,s){if(!e||null===e.id)return;const o=n[e.id]||{rank:0,id:0,played:0,wins:0,draws:0,losses:0,forfeits:0,scoreFor:0,scoreAgainst:0,scoreDifference:0,points:0};o.id=e.id,o.played++,"win"===e.result&&o.wins++,"draw"===e.result&&o.draws++,"loss"===e.result&&o.losses++,e.forfeit&&o.forfeits++,o.scoreFor+=e.score||0,o.scoreAgainst+=s&&s.score||0,o.scoreDifference=o.scoreFor-o.scoreAgainst;const r=t||(e=>3*e.wins+1*e.draws+0*e.losses);o.points=r(o),n[e.id]=o}for(const t of e)s(t.opponent1,t.opponent2),s(t.opponent2,t.opponent1);const o=Object.values(n).sort((e,t)=>t.points-e.points);let r={value:0,lastPoints:-1};for(const e of o)e.rank=r.lastPoints!==e.points?++r.value:r.value,r.lastPoints=e.points;return o}}]);