/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/helpers.ts":
/*!************************!*\
  !*** ./src/helpers.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRanking = exports.rankingHeader = exports.isMajorRound = exports.splitBy = void 0;\n\nfunction splitBy(array, key) {\n  const obj = Object();\n\n  for (const value of array) {\n    if (!obj[value[key]]) obj[value[key]] = [];\n    obj[value[key]].push(value);\n  }\n\n  return Object.values(obj);\n}\n\nexports.splitBy = splitBy;\nconst headers = {\n  'rank': {\n    value: '#',\n    tooltip: 'Rank'\n  },\n  'id': {\n    value: 'Name',\n    tooltip: 'Name'\n  },\n  'played': {\n    value: 'P',\n    tooltip: 'Played'\n  },\n  'wins': {\n    value: 'W',\n    tooltip: 'Wins'\n  },\n  'draws': {\n    value: 'D',\n    tooltip: 'Draws'\n  },\n  'losses': {\n    value: 'L',\n    tooltip: 'Losses'\n  },\n  'forfeits': {\n    value: 'F',\n    tooltip: 'Forfeits'\n  },\n  'scoreFor': {\n    value: 'SF',\n    tooltip: 'Score For'\n  },\n  'scoreAgainst': {\n    value: 'SA',\n    tooltip: 'Score Against'\n  },\n  'scoreDifference': {\n    value: '+/-',\n    tooltip: 'Score Difference'\n  },\n  'points': {\n    value: 'Pts',\n    tooltip: 'Points'\n  }\n};\n\nfunction isMajorRound(roundNumber) {\n  return roundNumber === 1 || roundNumber % 2 === 0;\n}\n\nexports.isMajorRound = isMajorRound;\n\nfunction rankingHeader(name) {\n  return headers[name];\n}\n\nexports.rankingHeader = rankingHeader;\n\nfunction getRanking(matches, pointsFormula) {\n  const teams = {};\n\n  function processTeam(current, other) {\n    if (!current || current.id === null) return;\n    const state = teams[current.id] || {\n      rank: 0,\n      id: 0,\n      played: 0,\n      wins: 0,\n      draws: 0,\n      losses: 0,\n      forfeits: 0,\n      scoreFor: 0,\n      scoreAgainst: 0,\n      scoreDifference: 0,\n      points: 0\n    };\n    state.id = current.id;\n    state.played++;\n    if (current.result === 'win') state.wins++;\n    if (current.result === 'draw') state.draws++;\n    if (current.result === 'loss') state.losses++;\n    if (current.forfeit) state.forfeits++;\n    state.scoreFor += current.score || 0;\n    state.scoreAgainst += other && other.score || 0;\n    state.scoreDifference = state.scoreFor - state.scoreAgainst;\n\n    const formula = pointsFormula || (ranking => 3 * ranking.wins + 1 * ranking.draws + 0 * ranking.losses);\n\n    state.points = formula(state);\n    teams[current.id] = state;\n  }\n\n  for (const match of matches) {\n    processTeam(match.opponent1, match.opponent2);\n    processTeam(match.opponent2, match.opponent1);\n  }\n\n  const rankings = Object.values(teams).sort((a, b) => b.points - a.points);\n  let rank = {\n    value: 0,\n    lastPoints: -1\n  };\n\n  for (const ranking of rankings) {\n    ranking.rank = rank.lastPoints !== ranking.points ? ++rank.value : rank.value;\n    rank.lastPoints = ranking.points;\n  }\n\n  return rankings;\n}\n\nexports.getRanking = getRanking;\n\n//# sourceURL=webpack:///./src/helpers.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n\nclass BracketsViewer {\n  constructor() {\n    this.teamRefsDOM = {};\n  }\n\n  render(rootSelector, data, config) {\n    const root = $(rootSelector);\n\n    if (root.length === 0) {\n      throw Error('Root not found. You must have a root element with id \"root\"');\n    }\n\n    this.config = {\n      participantOriginPlacement: config && config.participantOriginPlacement || 'before',\n      showSlotsOrigin: config && config.showSlotsOrigin || true,\n      showLowerBracketSlotsOrigin: config && config.showLowerBracketSlotsOrigin || false\n    };\n\n    switch (data.stage.type) {\n      case 'round_robin':\n        this.renderRoundRobin(root, data);\n        break;\n\n      case 'single_elimination':\n      case 'double_elimination':\n        this.renderElimination(root, data);\n        break;\n\n      default:\n        throw Error(`Unknown bracket type: ${data.stage.type}`);\n    }\n  }\n\n  renderRoundRobin(root, data) {\n    data.participants.map(participant => this.teamRefsDOM[participant.id] = []);\n    this.participants = data.participants;\n    const container = $('<div class=\"round-robin\">');\n    let groupNumber = 1;\n\n    for (const group of helpers_1.splitBy(data.matches, 'group_id')) {\n      const groupDOM = $('<section class=\"group\">').append($('<h2>').text(`Group ${groupNumber++}`));\n      ;\n      let roundNumber = 1;\n\n      for (const round of helpers_1.splitBy(group, 'round_id')) {\n        const roundDOM = $('<article class=\"round\">').append($('<h3>').text(`Round ${roundNumber}`));\n\n        for (const match of round) {\n          roundDOM.append(this.renderMatch(match));\n        }\n\n        groupDOM.append(roundDOM);\n        roundNumber++;\n      }\n\n      groupDOM.append(this.renderTable(group));\n      container.append(groupDOM);\n    }\n\n    root.append($('<h1>').text(data.stage.name));\n    root.append(container);\n  }\n\n  renderTable(matches) {\n    const rankings = helpers_1.getRanking(matches);\n    const table = $('<table>');\n    const headers = $('<tr>');\n\n    for (const prop in rankings[0]) {\n      const header = helpers_1.rankingHeader(prop);\n      headers.append($('<th>').text(header.value).attr('title', header.tooltip));\n    }\n\n    table.append(headers);\n\n    for (const ranking of rankings) {\n      const row = $('<tr>');\n\n      for (const prop in ranking) {\n        let data = ranking[prop];\n\n        if (prop === 'id') {\n          const participant = this.participants.find(team => team.id === data);\n\n          if (participant !== undefined) {\n            const cell = $('<td>').text(participant.name);\n            const id = participant.id;\n            this.teamRefsDOM[id].push(cell.get(0));\n            cell.hover(() => $(this.teamRefsDOM[id]).addClass('hover'), () => $(this.teamRefsDOM[id]).removeClass('hover'));\n            row.append(cell);\n            continue;\n          }\n        }\n\n        row.append($('<td>').text(data));\n      }\n\n      table.append(row);\n    }\n\n    return table;\n  }\n\n  renderElimination(root, data) {\n    data.participants.map(participant => this.teamRefsDOM[participant.id] = []);\n    const matchesByGroup = helpers_1.splitBy(data.matches, 'group_id');\n    this.participants = data.participants;\n    root.append($('<h1>').text(data.stage.name));\n\n    if (data.stage.type === 'single_elimination') {\n      const hasFinal = !!matchesByGroup[1];\n      this.renderBracket(root, helpers_1.splitBy(matchesByGroup[0], \"round_id\"), number => `Round ${number}`);\n\n      if (hasFinal) {\n        this.renderFinal('consolation_final', matchesByGroup[1]);\n      }\n    } else if (data.stage.type === 'double_elimination') {\n      const hasFinal = !!matchesByGroup[2];\n      this.renderBracket(root, helpers_1.splitBy(matchesByGroup[0], \"round_id\"), number => `WB Round ${number}`, false, hasFinal);\n      this.renderBracket(root, helpers_1.splitBy(matchesByGroup[1], \"round_id\"), number => `LB Round ${number}`, true);\n\n      if (hasFinal) {\n        this.renderFinal('grand_final', matchesByGroup[2]);\n      }\n    }\n  }\n  /**\r\n   * Renders a bracket.\r\n   */\n\n\n  renderBracket(root, matchesByRound, roundName, inLowerBracket, connectFinal) {\n    const bracket = $('<section class=\"bracket\">');\n    const roundCount = matchesByRound.length;\n    let roundNumber = 1;\n\n    for (const matches of matchesByRound) {\n      const roundDOM = $('<article class=\"round\">').append($('<h3>').text(roundName(roundNumber)));\n\n      for (const match of matches) {\n        const connection = this.getConnection(inLowerBracket, roundNumber, matchesByRound, connectFinal);\n        const matchLabel = this.getMatchLabel(match, roundNumber, roundCount, inLowerBracket);\n        const matchHint = this.getMatchHint(inLowerBracket, roundNumber, roundCount);\n        roundDOM.append(this.renderMatch(match, connection, matchLabel, matchHint, inLowerBracket));\n      }\n\n      bracket.append(roundDOM);\n      roundNumber++;\n    }\n\n    root.append(bracket);\n  }\n\n  getMatchHint(inLowerBracket, roundNumber, roundCount) {\n    if (!inLowerBracket && roundNumber === 1) return i => `Seed ${i}`;\n\n    if (inLowerBracket && helpers_1.isMajorRound(roundNumber)) {\n      const roundNumberWB = Math.ceil((roundNumber + 1) / 2);\n\n      let hint = i => `Loser of WB ${roundNumberWB}.${i}`;\n\n      if (roundNumber === roundCount - 2) hint = i => `Loser of WB Semi ${i}`;\n      if (roundNumber === roundCount) hint = () => 'Loser of WB Final';\n      return hint;\n    }\n\n    return undefined;\n  }\n\n  getConnection(inLowerBracket, roundNumber, matchesByRound, connectFinal) {\n    if (inLowerBracket) {\n      return {\n        connectPrevious: roundNumber > 1 && (roundNumber % 2 === 1 ? 'square' : 'straight'),\n        connectNext: roundNumber < matchesByRound.length && (roundNumber % 2 === 0 ? 'square' : 'straight')\n      };\n    }\n\n    return {\n      connectPrevious: roundNumber > 1 && 'square',\n      connectNext: roundNumber < matchesByRound.length ? 'square' : connectFinal ? 'straight' : false\n    };\n  }\n\n  getMatchLabel(match, roundNumber, roundCount, inLowerBracket) {\n    let matchPrefix = 'M';\n    if (inLowerBracket) matchPrefix = 'LB';else if (inLowerBracket === false) matchPrefix = 'WB';\n    const semiFinalRound = roundNumber === roundCount - 1;\n    const finalRound = roundNumber === roundCount;\n    let matchLabel = `${matchPrefix} ${roundNumber}.${match.number}`;\n    if (!inLowerBracket && semiFinalRound) matchLabel = `Semi ${match.number}`;\n    if (finalRound) matchLabel = 'Final';\n    return matchLabel;\n  }\n\n  renderFinal(type, matches) {\n    const upperBracket = $('.bracket').eq(0);\n    const grandFinalName = matches.length === 1 ? () => 'Grand Final' : i => `GF Round ${i + 1}`;\n\n    const grandFinalMatchHint = i => i === 0 ? () => 'Winner of LB Final' : undefined;\n\n    for (let i = 0; i < matches.length; i++) {\n      const matchLabel = type === 'consolation_final' ? 'Consolation Final' : grandFinalName(i);\n      const matchHint = type === 'consolation_final' ? i => `Loser of Semi ${i}` : grandFinalMatchHint(i);\n      const matchDOM = this.renderMatch(matches[i], {\n        connectPrevious: type === 'grand_final' && i === 0 && 'straight',\n        connectNext: matches.length === 2 && i === 0 && 'straight'\n      }, matchLabel, matchHint, undefined);\n      const roundDOM = $('<article class=\"round\">').append($('<h3>').text(matchLabel));\n      roundDOM.append(matchDOM);\n      upperBracket.append(roundDOM);\n    }\n  }\n\n  renderMatch(results, connection, label, hint, inLowerBracket) {\n    inLowerBracket = inLowerBracket || false;\n    const team1 = this.renderTeam(results.opponent1, hint, inLowerBracket);\n    const team2 = this.renderTeam(results.opponent2, hint, inLowerBracket);\n    const teams = $('<div class=\"teams\">');\n    if (label) teams.append($('<span>').text(label));\n    teams.append(team1).append(team2);\n    const match = $('<div class=\"match\">').append(teams);\n    if (!connection) return match;\n    if (connection.connectPrevious) teams.addClass('connect-previous');\n    if (connection.connectNext) match.addClass('connect-next');\n    if (connection.connectPrevious === 'straight') teams.addClass('straight');\n    if (connection.connectNext === 'straight') match.addClass('straight');\n    return match;\n  }\n\n  renderTeam(team, hint, inLowerBracket) {\n    const teamDOM = $(`<div class=\"team\">`);\n    const nameDOM = $('<div class=\"name\">');\n    const resultDOM = $('<div class=\"result\">');\n\n    if (team === null) {\n      nameDOM.text('BYE');\n    } else {\n      const participant = this.participants.find(participant => participant.id === team.id);\n\n      if (participant) {\n        nameDOM.text(participant.name);\n        this.renderTeamOrigin(nameDOM, team, inLowerBracket);\n      } else if (hint && team.position) {\n        this.renderHint(nameDOM, hint(team.position));\n      }\n\n      resultDOM.text(team.score === undefined ? '-' : team.score);\n\n      if (team.result && team.result === 'win') {\n        nameDOM.addClass('win');\n        resultDOM.addClass('win');\n        if (team.score === undefined) resultDOM.text('W'); // Win.\n      }\n\n      if (team.result && team.result === 'loss' || team.forfeit) {\n        nameDOM.addClass('loss');\n        resultDOM.addClass('loss');\n        if (team.forfeit) resultDOM.text('F'); // Forfeit.\n        else if (team.score === undefined) resultDOM.text('L'); // Loss.\n      }\n    }\n\n    teamDOM.append(nameDOM).append(resultDOM);\n\n    if (team && team.id !== null) {\n      const id = team.id;\n      this.teamRefsDOM[id].push(teamDOM.get(0));\n      teamDOM.hover(() => $(this.teamRefsDOM[id]).addClass('hover'), () => $(this.teamRefsDOM[id]).removeClass('hover'));\n    }\n\n    return teamDOM;\n  }\n\n  renderHint(name, hint) {\n    name.addClass('hint').text(hint);\n  }\n\n  renderTeamOrigin(name, team, inLowerBracket) {\n    if (team.position === undefined) return;\n    if (this.config.participantOriginPlacement === 'none') return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && inLowerBracket) return; // 'P' for position (where the participant comes from) and '#' for actual seeding.\n\n    const text = inLowerBracket ? `P${team.position}` : `#${team.position}`;\n    this.addTeamOrigin(name, text, this.config.participantOriginPlacement);\n  }\n\n  addTeamOrigin(name, text, placement) {\n    if (placement === 'before') name.prepend($('<span>').text(`${text} `));else name.append($('<span>').text(` (${text})`));\n  }\n\n}\n\nwindow.bracketsViewer = new BracketsViewer();\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/style.scss?");

/***/ })

/******/ });