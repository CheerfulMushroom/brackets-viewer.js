/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/.pnpm/brackets-model@1.3.0/node_modules/brackets-model/dist/index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/brackets-model@1.3.0/node_modules/brackets-model/dist/index.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Status = void 0;\r\n/**\r\n * The possible status for a match.\r\n */\r\nvar Status;\r\n(function (Status) {\r\n    /** The two matches leading to this one are not completed yet. */\r\n    Status[Status[\"Locked\"] = 0] = \"Locked\";\r\n    /** One participant is ready and waiting for the other one. */\r\n    Status[Status[\"Waiting\"] = 1] = \"Waiting\";\r\n    /** Both participants are ready to start. */\r\n    Status[Status[\"Ready\"] = 2] = \"Ready\";\r\n    /** The match is running. */\r\n    Status[Status[\"Running\"] = 3] = \"Running\";\r\n    /** The match is completed. */\r\n    Status[Status[\"Completed\"] = 4] = \"Completed\";\r\n    /** At least one participant completed his following match. */\r\n    Status[Status[\"Archived\"] = 5] = \"Archived\";\r\n})(Status = exports.Status || (exports.Status = {}));\r\n\n\n//# sourceURL=webpack:///./node_modules/.pnpm/brackets-model@1.3.0/node_modules/brackets-model/dist/index.js?");

/***/ }),

/***/ "./src/dom.ts":
/*!********************!*\
  !*** ./src/dom.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupConnection = exports.getFinalConnection = exports.getBracketConnection = exports.addTeamOrigin = exports.setupLoss = exports.setupWin = exports.setupHint = exports.createRankingHeaders = exports.createCell = exports.createRow = exports.createTable = exports.createResultContainer = exports.createNameContainer = exports.createTeamContainer = exports.createTeamsContainer = exports.createMatchLabel = exports.createMatchContainer = exports.createRoundContainer = exports.createGroupContainer = exports.createBracketContainer = exports.createRoundRobinContainer = exports.createTitle = void 0;\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n/**\n * Creates the title of the viewer.\n *\n * @param title The title to set.\n */\n\n\nfunction createTitle(title) {\n  const h1 = document.createElement('h1');\n  h1.innerText = title;\n  return h1;\n}\n\nexports.createTitle = createTitle;\n/**\n * Creates a container which contains a round-robin stage.\n */\n\nfunction createRoundRobinContainer() {\n  const container = document.createElement('div');\n  container.classList.add('round-robin');\n  return container;\n}\n\nexports.createRoundRobinContainer = createRoundRobinContainer;\n/**\n * Creates a container which contains a single bracket of a single or double elimination.\n */\n\nfunction createBracketContainer() {\n  const bracket = document.createElement('section');\n  bracket.classList.add('bracket');\n  return bracket;\n}\n\nexports.createBracketContainer = createBracketContainer;\n/**\n * Creates a container which contains a group.\n *\n * @param title Title of the group.\n */\n\nfunction createGroupContainer(title) {\n  const h2 = document.createElement('h2');\n  h2.innerText = title;\n  const groupDOM = document.createElement('section');\n  groupDOM.classList.add('group');\n  groupDOM.append(h2);\n  return groupDOM;\n}\n\nexports.createGroupContainer = createGroupContainer;\n/**\n * Creates a container which contains a round.\n *\n * @param title Title of the round.\n */\n\nfunction createRoundContainer(title) {\n  const h3 = document.createElement('h3');\n  h3.innerText = title;\n  const roundDOM = document.createElement('article');\n  roundDOM.classList.add('round');\n  roundDOM.append(h3);\n  return roundDOM;\n}\n\nexports.createRoundContainer = createRoundContainer;\n/**\n * Creates a container which contains a match.\n */\n\nfunction createMatchContainer() {\n  const match = document.createElement('div');\n  match.classList.add('match');\n  return match;\n}\n\nexports.createMatchContainer = createMatchContainer;\n/**\n * Creates a container which contains the label of a match.\n *\n * @param label The label of the match.\n * @param status The status to set as tooltip.\n */\n\nfunction createMatchLabel(label, status) {\n  const span = document.createElement('span');\n  span.innerText = label;\n  span.title = status;\n  return span;\n}\n\nexports.createMatchLabel = createMatchLabel;\n/**\n * Creates a container which contains the teams of a match.\n */\n\nfunction createTeamsContainer() {\n  const teams = document.createElement('div');\n  teams.classList.add('teams');\n  return teams;\n}\n\nexports.createTeamsContainer = createTeamsContainer;\n/**\n * Creates a container which contains a team.\n */\n\nfunction createTeamContainer() {\n  const teamDOM = document.createElement('div');\n  teamDOM.classList.add('team');\n  return teamDOM;\n}\n\nexports.createTeamContainer = createTeamContainer;\n/**\n * Creates a container which contains the name of a team.\n */\n\nfunction createNameContainer() {\n  const nameDOM = document.createElement('div');\n  nameDOM.classList.add('name');\n  return nameDOM;\n}\n\nexports.createNameContainer = createNameContainer;\n/**\n * Creates a container which contains the result of a match for a team.\n */\n\nfunction createResultContainer() {\n  const resultDOM = document.createElement('div');\n  resultDOM.classList.add('result');\n  return resultDOM;\n}\n\nexports.createResultContainer = createResultContainer;\n/**\n * Creates a table.\n */\n\nfunction createTable() {\n  return document.createElement('table');\n}\n\nexports.createTable = createTable;\n/**\n * Creates a table row.\n */\n\nfunction createRow() {\n  return document.createElement('tr');\n}\n\nexports.createRow = createRow;\n/**\n * Creates a table cell.\n *\n * @param data The data in the cell.\n */\n\nfunction createCell(data) {\n  const td = document.createElement('td');\n  td.innerText = String(data);\n  return td;\n}\n\nexports.createCell = createCell;\n/**\n * Creates the headers for a ranking table.\n *\n * @param ranking The object containing the ranking.\n */\n\nfunction createRankingHeaders(ranking) {\n  const headers = document.createElement('tr');\n  const firstItem = ranking[0];\n\n  for (const prop in firstItem) {\n    const header = helpers_1.rankingHeader(prop);\n    const th = document.createElement('th');\n    th.innerText = header.text;\n    th.setAttribute('title', header.tooltip);\n    headers.append(th);\n  }\n\n  return headers;\n}\n\nexports.createRankingHeaders = createRankingHeaders;\n/**\n * Sets a hint on a name container.\n *\n * @param nameContainer The name container.\n * @param hint The hint to set.\n */\n\nfunction setupHint(nameContainer, hint) {\n  nameContainer.classList.add('hint');\n  nameContainer.innerText = hint;\n}\n\nexports.setupHint = setupHint; // TODO: set win on parent\n\n/**\n * Sets a win for a team.\n *\n * @param nameContainer The name container.\n * @param resultContainer The result container.\n * @param team The team result.\n */\n\nfunction setupWin(nameContainer, resultContainer, team) {\n  if (team.result && team.result === 'win') {\n    nameContainer.classList.add('win');\n    resultContainer.classList.add('win');\n    if (team.score === undefined) resultContainer.innerText = 'W';\n  }\n}\n\nexports.setupWin = setupWin;\n/**\n * Sets a loss for a team.\n *\n * @param nameContainer The name container.\n * @param resultContainer The result container.\n * @param team The team result.\n */\n\nfunction setupLoss(nameContainer, resultContainer, team) {\n  if (team.result && team.result === 'loss' || team.forfeit) {\n    nameContainer.classList.add('loss');\n    resultContainer.classList.add('loss');\n    if (team.forfeit) resultContainer.innerText = 'F'; // Forfeit.\n    else if (team.score === undefined) resultContainer.innerText = 'L';\n  }\n}\n\nexports.setupLoss = setupLoss;\n/**\n * Adds the team origin to a name\n *\n * @param nameContainer The name container.\n * @param text The text to set (origin).\n * @param placement The placement of the team origin.\n */\n\nfunction addTeamOrigin(nameContainer, text, placement) {\n  const span = document.createElement('span');\n\n  if (placement === 'before') {\n    span.innerText = `${text} `;\n    nameContainer.prepend(span);\n  } else if (placement === 'after') {\n    span.innerText = ` (${text})`;\n    nameContainer.append(span);\n  }\n}\n\nexports.addTeamOrigin = addTeamOrigin;\n/**\n * Returns the connection for a given round in a bracket.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param inLowerBracket Whether the round is in lower bracket.\n * @param connectFinal Whether to connect to the final.\n */\n\nfunction getBracketConnection(roundNumber, roundCount, inLowerBracket, connectFinal) {\n  if (inLowerBracket) {\n    return {\n      connectPrevious: roundNumber > 1 && (roundNumber % 2 === 1 ? 'square' : 'straight'),\n      connectNext: roundNumber < roundCount && (roundNumber % 2 === 0 ? 'square' : 'straight')\n    };\n  }\n\n  return {\n    connectPrevious: roundNumber > 1 && 'square',\n    connectNext: roundNumber < roundCount ? 'square' : connectFinal ? 'straight' : false\n  };\n}\n\nexports.getBracketConnection = getBracketConnection;\n/**\n * Returns the connection for a given round in the final.\n *\n * @param finalType Type of final.\n * @param roundNumber Number of the round.\n * @param matchCount The count of matches.\n */\n\nfunction getFinalConnection(finalType, roundNumber, matchCount) {\n  return {\n    connectPrevious: finalType === 'grand_final' && roundNumber === 1 && 'straight',\n    connectNext: matchCount === 2 && roundNumber === 1 && 'straight'\n  };\n}\n\nexports.getFinalConnection = getFinalConnection;\n/**\n * Sets the connection a match containers.\n *\n * @param teamsContainer The teams container.\n * @param matchContainer The match container.\n * @param connection The connection to set.\n */\n\nfunction setupConnection(teamsContainer, matchContainer, connection) {\n  if (connection.connectPrevious) teamsContainer.classList.add('connect-previous');\n  if (connection.connectNext) matchContainer.classList.add('connect-next');\n  if (connection.connectPrevious === 'straight') teamsContainer.classList.add('straight');\n  if (connection.connectNext === 'straight') matchContainer.classList.add('straight');\n}\n\nexports.setupConnection = setupConnection;\n\n//# sourceURL=webpack:///./src/dom.ts?");

/***/ }),

/***/ "./src/helpers.ts":
/*!************************!*\
  !*** ./src/helpers.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRanking = exports.rankingHeader = exports.isMajorRound = exports.splitBy = void 0;\n/**\n * Splits an array based on values of a given key of the objects of the array.\n *\n * @param array The array to split.\n * @param key The key of T.\n */\n\nfunction splitBy(array, key) {\n  const obj = Object();\n\n  for (const value of array) {\n    if (!obj[value[key]]) obj[value[key]] = [];\n    obj[value[key]].push(value);\n  }\n\n  return Object.values(obj);\n}\n\nexports.splitBy = splitBy;\n/**\n * Indicates whether a round is major.\n *\n * @param roundNumber Number of the round.\n */\n\nfunction isMajorRound(roundNumber) {\n  return roundNumber === 1 || roundNumber % 2 === 0;\n}\n\nexports.isMajorRound = isMajorRound;\n/**\n * Headers of the ranking.\n */\n\nconst headers = {\n  'rank': {\n    text: '#',\n    tooltip: 'Rank'\n  },\n  'id': {\n    text: 'Name',\n    tooltip: 'Name'\n  },\n  'played': {\n    text: 'P',\n    tooltip: 'Played'\n  },\n  'wins': {\n    text: 'W',\n    tooltip: 'Wins'\n  },\n  'draws': {\n    text: 'D',\n    tooltip: 'Draws'\n  },\n  'losses': {\n    text: 'L',\n    tooltip: 'Losses'\n  },\n  'forfeits': {\n    text: 'F',\n    tooltip: 'Forfeits'\n  },\n  'scoreFor': {\n    text: 'SF',\n    tooltip: 'Score For'\n  },\n  'scoreAgainst': {\n    text: 'SA',\n    tooltip: 'Score Against'\n  },\n  'scoreDifference': {\n    text: '+/-',\n    tooltip: 'Score Difference'\n  },\n  'points': {\n    text: 'Pts',\n    tooltip: 'Points'\n  }\n};\n/**\n * Returns the header for a ranking property.\n *\n * @param itemName Name of the ranking property.\n */\n\nfunction rankingHeader(itemName) {\n  return headers[itemName];\n}\n\nexports.rankingHeader = rankingHeader;\n/**\n * Calculates the ranking based on a list of matches and a formula.\n *\n * @param matches The list of matches.\n * @param formula The points formula to apply.\n */\n\nfunction getRanking(matches, formula) {\n  formula = formula || (item => 3 * item.wins + 1 * item.draws + 0 * item.losses);\n\n  const rankingMap = {};\n\n  for (const match of matches) {\n    processParticipant(rankingMap, formula, match.opponent1, match.opponent2);\n    processParticipant(rankingMap, formula, match.opponent2, match.opponent1);\n  }\n\n  return createRanking(rankingMap);\n}\n\nexports.getRanking = getRanking;\n/**\n * Processes a participant and edits the ranking map.\n *\n * @param rankingMap The ranking map to edit.\n * @param formula The points formula to apply.\n * @param current The current participant.\n * @param other The opponent.\n */\n\nfunction processParticipant(rankingMap, formula, current, other) {\n  if (!current || current.id === null) return;\n  const state = rankingMap[current.id] || {\n    rank: 0,\n    id: 0,\n    played: 0,\n    wins: 0,\n    draws: 0,\n    losses: 0,\n    forfeits: 0,\n    scoreFor: 0,\n    scoreAgainst: 0,\n    scoreDifference: 0,\n    points: 0\n  };\n  state.id = current.id;\n  state.played++;\n  if (current.result === 'win') state.wins++;\n  if (current.result === 'draw') state.draws++;\n  if (current.result === 'loss') state.losses++;\n  if (current.forfeit) state.forfeits++;\n  state.scoreFor += current.score || 0;\n  state.scoreAgainst += other && other.score || 0;\n  state.scoreDifference = state.scoreFor - state.scoreAgainst;\n  state.points = formula(state);\n  rankingMap[current.id] = state;\n}\n/**\n * Creates the final ranking based on a ranking map. (Sort + Total points)\n *\n * @param rankingMap The ranking map (object).\n */\n\n\nfunction createRanking(rankingMap) {\n  const ranking = Object.values(rankingMap).sort((a, b) => b.points - a.points);\n  const rank = {\n    value: 0,\n    lastPoints: -1\n  };\n\n  for (const item of ranking) {\n    item.rank = rank.lastPoints !== item.points ? ++rank.value : rank.value;\n    rank.lastPoints = item.points;\n  }\n\n  return ranking;\n}\n\n//# sourceURL=webpack:///./src/helpers.ts?");

/***/ }),

/***/ "./src/lang.ts":
/*!*********************!*\
  !*** ./src/lang.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLoserBracketRoundName = exports.getWinnerBracketRoundName = exports.getRoundName = exports.getGroupName = exports.getGrandFinalName = exports.getMatchStatus = exports.getFinalMatchHint = exports.getFinalMatchLabel = exports.getMatchLabel = exports.getMatchHint = void 0;\n\nconst brackets_model_1 = __webpack_require__(/*! brackets-model */ \"./node_modules/.pnpm/brackets-model@1.3.0/node_modules/brackets-model/dist/index.js\");\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\"); // TODO: rename match hint to position hint\n\n/**\n * Returns a match hint based on rounds information.\n *\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param inLowerBracket Whether the round is in lower bracket.\n */\n\n\nfunction getMatchHint(roundNumber, roundCount, inLowerBracket) {\n  if (!inLowerBracket && roundNumber === 1) return i => `Seed ${i}`;\n\n  if (inLowerBracket && helpers_1.isMajorRound(roundNumber)) {\n    const roundNumberWB = Math.ceil((roundNumber + 1) / 2);\n\n    let hint = i => `Loser of WB ${roundNumberWB}.${i}`;\n\n    if (roundNumber === roundCount - 2) hint = i => `Loser of WB Semi ${i}`;\n    if (roundNumber === roundCount) hint = () => 'Loser of WB Final';\n    return hint;\n  }\n\n  return undefined;\n}\n\nexports.getMatchHint = getMatchHint;\n/**\n * Returns the label of a match.\n *\n * @param matchNumber Number of the match.\n * @param roundNumber Number of the round.\n * @param roundCount Count of rounds.\n * @param inLowerBracket Whether the round is in lower bracket.\n */\n\nfunction getMatchLabel(matchNumber, roundNumber, roundCount, inLowerBracket) {\n  let matchPrefix = 'M';\n  if (inLowerBracket) matchPrefix = 'LB';else if (inLowerBracket === false) matchPrefix = 'WB';\n  const semiFinalRound = roundNumber === roundCount - 1;\n  const finalRound = roundNumber === roundCount;\n  let matchLabel = `${matchPrefix} ${roundNumber}.${matchNumber}`;\n  if (!inLowerBracket && semiFinalRound) matchLabel = `Semi ${matchNumber}`;\n  if (finalRound) matchLabel = 'Final';\n  return matchLabel;\n}\n\nexports.getMatchLabel = getMatchLabel; // TODO: refactor this, grandFinalName isn't always used... no need to pass it in the first place...\n\n/**\n * Returns the label of a match in final.\n *\n * @param finalType Type of the final.\n * @param grandFinalName Name of the final.\n * @param roundNumber Number of the round.\n */\n\nfunction getFinalMatchLabel(finalType, grandFinalName, roundNumber) {\n  return finalType === 'consolation_final' ? 'Consolation Final' : grandFinalName(roundNumber);\n}\n\nexports.getFinalMatchLabel = getFinalMatchLabel;\n/**\n * Returns the hint of a match in final.\n *\n * @param finalType Type of the final.\n * @param roundNumber Number of the round.\n */\n\nfunction getFinalMatchHint(finalType, roundNumber) {\n  // Single elimination.\n  if (finalType === 'consolation_final') return number => `Loser of Semi ${number}`; // Double elimination.\n\n  if (roundNumber === 1) return () => 'Winner of LB Final';\n  return undefined;\n}\n\nexports.getFinalMatchHint = getFinalMatchHint;\n/**\n * Returns the status of a match.\n *\n * @param status The match status.\n */\n\nfunction getMatchStatus(status) {\n  switch (status) {\n    case brackets_model_1.Status.Locked:\n      return 'Locked';\n\n    case brackets_model_1.Status.Waiting:\n      return 'Waiting';\n\n    case brackets_model_1.Status.Ready:\n      return 'Ready';\n\n    case brackets_model_1.Status.Running:\n      return 'Running';\n\n    case brackets_model_1.Status.Completed:\n      return 'Completed';\n\n    case brackets_model_1.Status.Archived:\n      return 'Archived';\n  }\n}\n\nexports.getMatchStatus = getMatchStatus;\n/**\n * Returns the name of a grand final phase.\n *\n * @param roundCount Count of final rounds.\n */\n\nfunction getGrandFinalName(roundCount) {\n  return roundCount === 1 ? () => 'Grand Final' : roundNumber => `GF Round ${roundNumber}`;\n}\n\nexports.getGrandFinalName = getGrandFinalName;\n/**\n * Returns the name of a group.\n *\n * @param groupNumber Number of the group.\n */\n\nfunction getGroupName(groupNumber) {\n  return `Group ${groupNumber}`;\n}\n\nexports.getGroupName = getGroupName;\n/**\n * Returns the name of a round.\n *\n * @param roundNumber Number of the round.\n */\n\nfunction getRoundName(roundNumber) {\n  return `Round ${roundNumber}`;\n}\n\nexports.getRoundName = getRoundName;\n/**\n * Returns the name of a round in the winner bracket of a double elimination stage.\n *\n * @param roundNumber Number of the round.\n */\n\nfunction getWinnerBracketRoundName(roundNumber) {\n  return `WB Round ${roundNumber}`;\n}\n\nexports.getWinnerBracketRoundName = getWinnerBracketRoundName;\n/**\n * Returns the name of a round in the loser bracket of a double elimination stage.\n *\n * @param roundNumber Number of the round.\n */\n\nfunction getLoserBracketRoundName(roundNumber) {\n  return `LB Round ${roundNumber}`;\n}\n\nexports.getLoserBracketRoundName = getLoserBracketRoundName; // TODO: add letters as traduction (W, L, D, F and all ranking headers)\n\n//# sourceURL=webpack:///./src/lang.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BracketsViewer = void 0;\n\n__webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n\nconst helpers_1 = __webpack_require__(/*! ./helpers */ \"./src/helpers.ts\");\n\nconst dom = __importStar(__webpack_require__(/*! ./dom */ \"./src/dom.ts\"));\n\nconst lang = __importStar(__webpack_require__(/*! ./lang */ \"./src/lang.ts\"));\n\nclass BracketsViewer {\n  constructor() {\n    this.teamRefsDOM = {};\n  }\n  /**\n   * Renders a stage (round-robin, single or double elimination).\n   *\n   * @param rootSelector The DOM selector for the root element.\n   * @param data The data to display.\n   * @param config An optional configuration for the viewer.\n   */\n\n\n  render(rootSelector, data, config) {\n    const root = document.querySelector(rootSelector);\n    if (!root) throw Error('Root not found. You must have a root element with id \"root\"');\n    this.config = {\n      participantOriginPlacement: config && config.participantOriginPlacement || 'before',\n      showSlotsOrigin: config && config.showSlotsOrigin !== undefined ? config.showSlotsOrigin : true,\n      showLowerBracketSlotsOrigin: config && config.showLowerBracketSlotsOrigin !== undefined ? config.showLowerBracketSlotsOrigin : true,\n      highlightParticipantOnHover: config && config.highlightParticipantOnHover !== undefined ? config.highlightParticipantOnHover : true\n    };\n    this.participants = data.participants;\n    data.participants.forEach(participant => this.teamRefsDOM[participant.id] = []);\n    const matchesByGroup = helpers_1.splitBy(data.matches, 'group_id');\n\n    switch (data.stage.type) {\n      case 'round_robin':\n        this.renderRoundRobin(root, data.stage.name, matchesByGroup);\n        break;\n\n      case 'single_elimination':\n      case 'double_elimination':\n        this.renderElimination(root, data.stage.name, data.stage.type, matchesByGroup);\n        break;\n\n      default:\n        throw Error(`Unknown bracket type: ${data.stage.type}`);\n    }\n  }\n  /**\n   * Renders a round-robin stage.\n   *\n   * @param root The root element.\n   * @param stageName Name of the stage.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderRoundRobin(root, stageName, matchesByGroup) {\n    const container = dom.createRoundRobinContainer();\n    let groupNumber = 1;\n\n    for (const groupMatches of matchesByGroup) {\n      const groupContainer = dom.createGroupContainer(lang.getGroupName(groupNumber++));\n      const matchesByRound = helpers_1.splitBy(groupMatches, 'round_id');\n      let roundNumber = 1;\n\n      for (const roundMatches of matchesByRound) {\n        const roundContainer = dom.createRoundContainer(lang.getRoundName(roundNumber++));\n\n        for (const match of roundMatches) roundContainer.append(this.createMatch(match));\n\n        groupContainer.append(roundContainer);\n      }\n\n      groupContainer.append(this.createRanking(groupMatches));\n      container.append(groupContainer);\n    }\n\n    root.append(dom.createTitle(stageName), container);\n  }\n  /**\n   * Renders an elimination stage (single or double).\n   *\n   * @param root The root element.\n   * @param stageName Name of the stage.\n   * @param type Type of the stage.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderElimination(root, stageName, type, matchesByGroup) {\n    root.append(dom.createTitle(stageName));\n    if (type === 'single_elimination') this.renderSingleElimination(root, matchesByGroup);else this.renderDoubleElimination(root, matchesByGroup);\n  }\n  /**\n   * Renders a single elimination stage.\n   *\n   * @param root The root element.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderSingleElimination(root, matchesByGroup) {\n    const hasFinal = matchesByGroup[1] !== undefined;\n    this.renderBracket(root, helpers_1.splitBy(matchesByGroup[0], 'round_id'), lang.getRoundName);\n    if (hasFinal) this.renderFinal('consolation_final', matchesByGroup[1]);\n  }\n  /**\n   * Renders a double elimination stage.\n   *\n   * @param root The root element.\n   * @param matchesByGroup A list of matches for each group.\n   */\n\n\n  renderDoubleElimination(root, matchesByGroup) {\n    const hasFinal = matchesByGroup[2] !== undefined;\n    this.renderBracket(root, helpers_1.splitBy(matchesByGroup[0], 'round_id'), lang.getWinnerBracketRoundName, false, hasFinal);\n    this.renderBracket(root, helpers_1.splitBy(matchesByGroup[1], 'round_id'), lang.getLoserBracketRoundName, true);\n    if (hasFinal) this.renderFinal('grand_final', matchesByGroup[2]);\n  }\n  /**\n   * Renders a bracket.\n   *\n   * @param root The root element.\n   * @param matchesByRound A list of matches for each round.\n   * @param roundName A function giving a round's name based on its number.\n   * @param inLowerBracket Whether the bracket is in lower bracket.\n   * @param connectFinal Whether to connect the last match of the bracket to the final.\n   */\n\n\n  renderBracket(root, matchesByRound, roundName, inLowerBracket, connectFinal) {\n    const bracketContainer = dom.createBracketContainer();\n    const roundCount = matchesByRound.length;\n    let roundNumber = 1;\n\n    for (const matches of matchesByRound) {\n      const roundContainer = dom.createRoundContainer(roundName(roundNumber));\n\n      for (const match of matches) roundContainer.append(this.createBracketMatch(roundNumber, roundCount, match, inLowerBracket, connectFinal));\n\n      bracketContainer.append(roundContainer);\n      roundNumber++;\n    }\n\n    root.append(bracketContainer);\n  }\n  /**\n   * Renders a final group.\n   *\n   * @param finalType Type of the final.\n   * @param matches Matches of the final.\n   */\n\n\n  renderFinal(finalType, matches) {\n    const upperBracket = document.querySelector('.bracket');\n    if (!upperBracket) throw Error('Upper bracket not found.');\n    const grandFinalName = lang.getGrandFinalName(matches.length);\n    const winnerWb = matches[0].opponent1;\n    const finalsToDisplay = winnerWb && winnerWb.id != null && winnerWb.result != \"win\" ? 2 : 1;\n    const finalMatches = matches.slice(0, finalsToDisplay);\n\n    for (let i = 0; i < finalMatches.length; i++) {\n      const roundNumber = i + 1;\n      const roundContainer = dom.createRoundContainer(lang.getFinalMatchLabel(finalType, grandFinalName, roundNumber));\n      roundContainer.append(this.createFinalMatch(finalType, grandFinalName, finalMatches, roundNumber));\n      upperBracket.append(roundContainer);\n    }\n  }\n  /**\n   * Creates a ranking table based on matches of a round-robin stage.\n   *\n   * @param matches The list of matches.\n   */\n\n\n  createRanking(matches) {\n    const table = dom.createTable();\n    const ranking = helpers_1.getRanking(matches);\n    table.append(dom.createRankingHeaders(ranking));\n\n    for (const item of ranking) table.append(this.createRankingRow(item));\n\n    return table;\n  }\n  /**\n   * Creates a row of the ranking table.\n   *\n   * @param item Item of the ranking.\n   */\n\n\n  createRankingRow(item) {\n    const row = dom.createRow();\n\n    for (const prop in item) {\n      const data = item[prop];\n\n      if (prop === 'id') {\n        const participant = this.participants.find(team => team.id === data);\n\n        if (participant !== undefined) {\n          const cell = dom.createCell(participant.name);\n          this.setupMouseHover(participant.id, cell);\n          row.append(cell);\n          continue;\n        }\n      }\n\n      row.append(dom.createCell(data));\n    }\n\n    return row;\n  }\n  /**\n   * Creates a match in a bracket.\n   *\n   * @param roundNumber Number of the round.\n   * @param roundCount Count of rounds.\n   * @param match Information about the match.\n   * @param inLowerBracket Whether the match is in lower bracket.\n   * @param connectFinal Whether to connect this match to the final if it happens to be the last one of the bracket.\n   */\n\n\n  createBracketMatch(roundNumber, roundCount, match, inLowerBracket, connectFinal) {\n    const connection = dom.getBracketConnection(roundNumber, roundCount, inLowerBracket, connectFinal);\n    const matchLabel = lang.getMatchLabel(match.number, roundNumber, roundCount, inLowerBracket);\n    const matchHint = lang.getMatchHint(roundNumber, roundCount, inLowerBracket);\n    return this.createMatch(match, connection, matchLabel, matchHint, inLowerBracket);\n  }\n  /**\n   * Creates a match in a final.\n   *\n   * @param type Type of the final.\n   * @param grandFinalName A function giving a grand final phase's name based on the round number.\n   * @param matches Matches of the final.\n   * @param roundNumber Number of the round.\n   */\n\n\n  createFinalMatch(type, grandFinalName, matches, roundNumber) {\n    const connection = dom.getFinalConnection(type, roundNumber, matches.length);\n    const matchLabel = lang.getFinalMatchLabel(type, grandFinalName, roundNumber);\n    const matchHint = lang.getFinalMatchHint(type, roundNumber);\n    return this.createMatch(matches[roundNumber], connection, matchLabel, matchHint);\n  }\n  /**\n   * Creates a match based on its results.\n   *\n   * @param results Results of the match.\n   * @param connection Connection of this match with the others.\n   * @param label Label of the match.\n   * @param hint Hint for the match.\n   * @param inLowerBracket Whether the match is in lower bracket.\n   */\n\n\n  createMatch(results, connection, label, hint, inLowerBracket) {\n    inLowerBracket = inLowerBracket || false;\n    const match = dom.createMatchContainer();\n    const teams = dom.createTeamsContainer();\n    const team1 = this.createTeam(results.opponent1, hint, inLowerBracket);\n    const team2 = this.createTeam(results.opponent2, hint, inLowerBracket);\n    if (label) teams.append(dom.createMatchLabel(label, lang.getMatchStatus(results.status)));\n    teams.append(team1, team2);\n    match.append(teams);\n    if (!connection) return match;\n    dom.setupConnection(teams, match, connection);\n    return match;\n  } // TODO: get rid of the word \"team\"\n\n  /**\n   * Creates a team for a match.\n   *\n   * @param team Information about the team.\n   * @param hint Hint of the match.\n   * @param inLowerBracket Whether the match is in lower bracket.\n   */\n\n\n  createTeam(team, hint, inLowerBracket) {\n    const teamContainer = dom.createTeamContainer();\n    const nameContainer = dom.createNameContainer();\n    const resultContainer = dom.createResultContainer();\n    if (team === null) nameContainer.innerText = 'BYE';else this.renderParticipant(nameContainer, resultContainer, team, hint, inLowerBracket);\n    teamContainer.append(nameContainer, resultContainer);\n    if (team && team.id !== null) this.setupMouseHover(team.id, teamContainer);\n    return teamContainer;\n  }\n  /**\n   * Renders a participant.\n   *\n   * @param nameContainer The name container.\n   * @param resultContainer The result container.\n   * @param team The participant result.\n   * @param hint Hint for the participant.\n   * @param inLowerBracket Whether the match is in lower bracket.\n   */\n\n\n  renderParticipant(nameContainer, resultContainer, team, hint, inLowerBracket) {\n    const participant = this.participants.find(item => item.id === team.id);\n\n    if (participant) {\n      nameContainer.innerText = participant.name;\n      this.renderTeamOrigin(nameContainer, team, inLowerBracket);\n    } else this.renderHint(nameContainer, team, hint, inLowerBracket);\n\n    resultContainer.innerText = `${team.score || '-'}`;\n    dom.setupWin(nameContainer, resultContainer, team);\n    dom.setupLoss(nameContainer, resultContainer, team);\n  }\n  /**\n   * Renders a hint for a participant.\n   *\n   * @param nameContainer The name container.\n   * @param team The participant result.\n   * @param hint Hint for the participant.\n   * @param inLowerBracket Whether the match is in lower bracket.\n   */\n\n\n  renderHint(nameContainer, team, hint, inLowerBracket) {\n    if (hint === undefined || team.position === undefined) return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && inLowerBracket) return;\n    dom.setupHint(nameContainer, hint(team.position));\n  }\n  /**\n   * Renders a participant's origin.\n   *\n   * @param nameContainer The name container.\n   * @param team The participant result.\n   * @param inLowerBracket Whether the match is in lower bracket.\n   */\n\n\n  renderTeamOrigin(nameContainer, team, inLowerBracket) {\n    if (team.position === undefined) return;\n    if (this.config.participantOriginPlacement === 'none') return;\n    if (!this.config.showSlotsOrigin) return;\n    if (!this.config.showLowerBracketSlotsOrigin && inLowerBracket) return; // 'P' for position (where the participant comes from) and '#' for actual seeding.\n\n    const origin = inLowerBracket ? `P${team.position}` : `#${team.position}`;\n    dom.addTeamOrigin(nameContainer, origin, this.config.participantOriginPlacement);\n  }\n  /**\n   * Sets mouse hover events for a participant.\n   *\n   * @param participantId ID of the participant.\n   * @param element The dom element to add events to.\n   */\n\n\n  setupMouseHover(participantId, element) {\n    if (!this.config.highlightParticipantOnHover) return;\n    this.teamRefsDOM[participantId].push(element);\n    element.addEventListener('mouseover', () => {\n      this.teamRefsDOM[participantId].forEach(el => el.classList.add('hover'));\n    });\n    element.addEventListener('mouseleave', () => {\n      this.teamRefsDOM[participantId].forEach(el => el.classList.remove('hover'));\n    });\n  }\n\n}\n\nexports.BracketsViewer = BracketsViewer;\nwindow.bracketsViewer = new BracketsViewer();\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/style.scss?");

/***/ })

/******/ });