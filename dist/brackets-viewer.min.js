/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(/*! ./style.scss */ \"./src/style.scss\");\n\nconst teamRefsDOM = {};\nwindow.bracketsViewer = {\n  render: data => {\n    switch (data.type) {\n      case 'double_elimination':\n        renderDoubleElimination(data);\n        break;\n\n      default:\n        throw Error(`Unknown bracket type: ${data.type}`);\n    }\n  }\n};\n\nfunction renderDoubleElimination(data) {\n  checkSizes(data);\n  data.teams.map(team => teamRefsDOM[team] = []);\n  $('section').append($('<h1>').text(data.name));\n  const {\n    losersWB,\n    winnerWB\n  } = renderWinnerBracket(data.teams, data.results[0]);\n  const winnerLB = renderLoserBracket(losersWB, data.results[1], data.minorOrdering || defaultMinorOrdering[data.teams.length]);\n  renderGrandFinal(winnerWB, winnerLB, data.results[2][0][0]);\n}\n/**\r\n * Renders the winner bracket (WB) and returns all the losers and the final winner.\r\n */\n\n\nfunction renderWinnerBracket(teams, results) {\n  const winnerBracket = $('<div class=\"winner bracket\">');\n  const losers = []; // At first, all players play in WB.\n\n  let winners = teams;\n  let players;\n\n  for (let roundId = 0; roundId < results.length; roundId++) {\n    const roundScores = results[roundId]; // Players of this round are the last one's winners.\n\n    players = makePairs(winners);\n    winners = [];\n    const roundDOM = $('<div class=\"round\">').append($('<h2>').text(`WB Round ${roundId + 1}`));\n    const roundLosers = [];\n\n    for (let matchId = 0; matchId < roundScores.length; matchId++) {\n      const opponents = players[matchId];\n      const matchScores = roundScores[matchId];\n      roundDOM.append(renderMatch(opponents, matchScores, {\n        connectPrevious: roundId > 0,\n        connectNext: true\n      }));\n\n      if (matchScores[0] > matchScores[1]) {\n        winners.push(opponents[0]);\n        roundLosers.push(opponents[1]);\n      } else if (matchScores[1] > matchScores[0]) {\n        winners.push(opponents[1]);\n        roundLosers.push(opponents[0]);\n      } else {\n        throw Error(`${opponents[matchId][0]} et ${opponents[matchId][1]} sont à égalité !`);\n      }\n    }\n\n    winnerBracket.append(roundDOM);\n    losers.push(roundLosers);\n  }\n\n  $('section').append(winnerBracket);\n  return {\n    losersWB: losers,\n    winnerWB: winners[0]\n  };\n}\n\nfunction renderLoserBracket(fromWB, results, minorOrdering) {\n  const loserBracket = $('<div class=\"loser bracket\">');\n  let winners = [];\n  let players;\n\n  for (let roundId = 0; roundId < results.length; roundId++) {\n    const round = results[roundId];\n\n    if (roundId === 0) {\n      // In the first LB round are the losers from the first WB round.\n      players = makePairs(ordering[minorOrdering[0]](fromWB[0]));\n    } else if (roundId % 2 === 1) {\n      // Each minor LB round matches the winners of the previous major LB round against the losers of the corresponding WB round. \n      const roundWB = Math.ceil(roundId / 2);\n      players = makePairs(ordering[minorOrdering[roundWB]](fromWB[roundWB]), winners);\n    } else {\n      // Each major LB round matches the winners of the previous round.\n      players = makePairs(winners);\n    }\n\n    winners = [];\n    const roundDOM = $('<div class=\"round\">').append($('<h2>').text(`LB Round ${roundId + 1}`));\n\n    for (let matchId = 0; matchId < round.length; matchId++) {\n      const opponents = players[matchId];\n      const scores = round[matchId];\n      roundDOM.append(renderMatch(opponents, scores, {\n        connectPrevious: roundId > 0,\n        connectNext: roundId < results.length - 1\n      }));\n\n      if (scores[0] > scores[1]) {\n        winners.push(opponents[0]);\n      } else if (scores[1] > scores[0]) {\n        winners.push(opponents[1]);\n      } else {\n        throw Error(`${opponents[matchId][0]} et ${opponents[matchId][1]} sont à égalité !`);\n      }\n    }\n\n    loserBracket.append(roundDOM);\n  }\n\n  $('section').append(loserBracket);\n  return winners[0];\n}\n\nfunction renderGrandFinal(winnerWB, winnerLB, scores) {\n  const match = renderMatch([winnerWB, winnerLB], scores, {\n    connectPrevious: true,\n    connectNext: false\n  });\n  const roundDOM = $('<div class=\"round\">').append($('<h2>').text(\"Grand Final\"));\n  roundDOM.append(match);\n  $('.winner.bracket').append(roundDOM);\n}\n\nfunction renderMatch(opponents, scores, connection) {\n  const team1 = renderTeam(opponents[0], scores[0], scores[0] > scores[1]);\n  const team2 = renderTeam(opponents[1], scores[1], scores[1] > scores[0]);\n  const teams = $('<div class=\"teams\">').append(team1).append(team2);\n  const match = $('<div class=\"match\">').append(teams);\n\n  if (connection && connection.connectPrevious) {\n    teams.addClass('connect-previous');\n  }\n\n  if (connection && connection.connectNext) {\n    match.addClass('connect-next');\n  }\n\n  return match;\n}\n\nfunction renderTeam(name, score, win) {\n  const nameDOM = $('<div class=\"name\">').text(name);\n  const scoreDOM = $('<div class=\"score\">').text(score);\n\n  if (win) {\n    nameDOM.addClass('win');\n    scoreDOM.addClass('win');\n  }\n\n  const team = $(`<div class=\"team\">`).append(nameDOM).append(scoreDOM);\n  teamRefsDOM[name].push(team.get(0));\n  return team.hover(() => $(teamRefsDOM[name]).addClass('hover'), () => $(teamRefsDOM[name]).removeClass('hover'));\n}\n\nfunction makePairs(left, right) {\n  if (!right) {\n    ensureEvenSized(left);\n    return left.map((current, i) => i % 2 === 0 ? [current, left[i + 1]] : []).filter(v => v.length > 0);\n  }\n\n  ensureEquallySized(left, right);\n  return left.map((current, i) => [current, right[i]]);\n}\n\nfunction ensureEvenSized(array) {\n  if (array.length % 2 === 1) {\n    throw Error('La taille du tableau doit être paire.');\n  }\n}\n\nfunction ensureEquallySized(left, right) {\n  if (left.length !== right.length) {\n    throw Error('La taille des tableaux doit être égale.');\n  }\n}\n\nfunction checkSizes(data) {\n  if (!Number.isInteger(Math.log2(data.teams.length))) {\n    throw Error('Le nombre d\\'équipes doit être une puissance de deux.');\n  }\n\n  if (data.minorOrdering && data.minorOrdering.length !== Math.log2(data.teams.length)) {\n    throw Error('Le nombre d\\'éléments dans minorOrdering doit correspondre au nombre de tours mineurs dans le loser bracket.');\n  }\n} // https://web.archive.org/web/20200601102344/https://tl.net/forum/sc2-tournaments/202139-superior-double-elimination-losers-bracket-seeding\n\n\nconst ordering = {\n  natural: array => [...array],\n  reverse: array => array.reverse(),\n  half_shift: array => [...array.slice(array.length / 2), ...array.slice(0, array.length / 2)],\n  reverse_half_shift: array => [...array.slice(array.length / 2).reverse(), ...array.slice(0, array.length / 2).reverse()],\n  pair_flip: array => {\n    const result = [];\n\n    for (let i = 0; i < array.length; i += 2) result.push(array[i + 1], array[i]);\n\n    return result;\n  }\n};\nconst defaultMinorOrdering = {\n  8: ['natural', 'reverse', 'natural'],\n  16: ['natural', 'reverse_half_shift', 'reverse', 'natural'],\n  32: ['natural', 'reverse', 'half_shift', 'natural', 'natural'],\n  64: ['natural', 'reverse', 'half_shift', 'reverse', 'natural', 'natural'],\n  128: ['natural', 'reverse', 'half_shift', 'pair_flip', 'pair_flip', 'pair_flip', 'natural']\n};\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ }),

/***/ "./src/style.scss":
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/style.scss?");

/***/ })

/******/ });